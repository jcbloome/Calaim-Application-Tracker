
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy:
     * This ruleset enforces a strict user-ownership model. All user-generated data,
     * such as applications and their related documents, is stored in a hierarchical
     * structure under the user's unique ID (`/users/{userId}`). This ensures that
     * by default, users can only access their own data. An administrative role
     * (`/roles_admin`) is defined to grant privileged read/write access across all
     * user data for administrative purposes.
     *
     * Data Structure:
     * The data is organized hierarchically starting from `/users/{userId}`. Each user
     * document contains a subcollection for their `applications`. All other data
     * points, like contacts, locations, and form statuses, are nested as subcollections
     * under the specific application they relate to. This structure simplifies
     * ownership-based security rules.
     *
     * Key Security Decisions:
     * - Default Deny: All paths are closed by default. Access is granted explicitly.
     * - User Data Isolation: All access controls for the `/users/{userId}` data tree
     *   are based on the `userId` from the path, ensuring a user can only interact
     *   with their own data branch.
     * - No User Enumeration: Listing documents in the top-level `/users` and `/roles_admin`
     *   collections is explicitly forbidden to prevent enumeration of all users or admins.
     * - Admin Privileges: Users whose UID exists in the `/roles_admin` collection are
     *   granted full read/write access to all user data for moderation and support.
     * - Admin Role Management: The `/roles_admin` collection is read-only and unlistable
     *   from the client. Roles must be managed manually via the Firebase Console or through
     *   a trusted server-side environment for maximum security.
     *
     * Denormalization for Authorization:
     * To ensure fast and secure authorization, documents contain fields that simplify
     * rule logic. For example, an `Application` document contains a `userId` field,
     * which is validated against the path on creation to ensure relational integrity.
     * This avoids costly and slow `get()` calls in security rules. The admin role is
     * managed through the existence of a document in `/roles_admin`, which is a
     * simple and performant lookup.
     *
     * Structural Segregation:
     * User data and administrative roles are stored in separate top-level collections
     * (`/users` and `/roles_admin`). This clear separation ensures that security rules
     * for application data do not get mixed with rules for administrative access control,
     * leading to a more secure and maintainable ruleset.
     */

    // =================================
    //         Helper Functions
    // =================================

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     * @param userId The UID to check against the authenticated user.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }


    /**
     * Checks if the user has an admin role.
     * Admin status is conferred by the existence of a document for the user
     * in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

     /**
     * Checks if the user has a super admin role.
     * Super Admin status is conferred by the existence of a document for the user
     * in the /roles_super_admin collection.
     */
    function isSuperAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_super_admin/$(request.auth.uid));
    }

    /**
     * Grants access if the user is the owner of the resource OR is an admin.
     * @param userId The UID of the document's owner.
     */
    function isOwnerOrAdmin(userId) {
      return isOwner(userId) || isAdmin() || isSuperAdmin();
    }

    /**
     * Grants access for state-changing operations (update, delete) if the user
     * is the owner or an admin, AND the document already exists.
     * This prevents modifying or deleting non-existent data.
     * @param userId The UID of the document's owner.
     */
    function isExistingOwnerOrAdmin(userId) {
      return isOwnerOrAdmin(userId) && resource != null;
    }

    /**
     * Validates required relational fields on Application document creation.
     * Ensures the internal userId reference points to the correct owner.
     * @param userId The user's UID from the path.
     */
    function hasValidApplicationDataOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces immutability of the Application's owner ID on update.
     */
    function hasValidApplicationDataOnUpdate() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * Validates relational fields for any subcollection document under an application.
     * Ensures the internal applicationId reference points to the correct parent application.
     * @param applicationId The parent application's ID from the path.
     */
    function hasValidSubcollectionDataOnCreate(applicationId) {
      return request.resource.data.applicationId == applicationId;
    }

    /**
     * Enforces immutability of a subcollection document's parent application ID on update.
     */
    function hasValidSubcollectionDataOnUpdate() {
      return request.resource.data.applicationId == resource.data.applicationId;
    }

    // =================================
    //         Collection Rules
    // =================================

    // This rule allows collection group queries on 'applications' for admins.
    match /{path=**}/applications/{applicationId} {
      allow read, write: if isAdmin() || isSuperAdmin();
    }

    // Rules for the 'users' collection itself (listing)
    match /users {
      allow list: if isSuperAdmin();
    }

    // Rules for individual user documents
    match /users/{userId} {
      allow get: if isOwnerOrAdmin(userId);
      allow write: if isOwner(userId);
      allow delete: if isOwnerOrAdmin(userId);

      /**
       * @description Rules for a user's CalAIM applications.
       * @path /users/{userId}/applications/{applicationId}
       */
      match /applications/{applicationId} {
        allow get, list: if isOwnerOrAdmin(userId);
        allow create: if isOwnerOrAdmin(userId) && hasValidApplicationDataOnCreate(userId);
        allow update: if isExistingOwnerOrAdmin(userId) && hasValidApplicationDataOnUpdate();
        allow delete: if isExistingOwnerOrAdmin(userId);

        // Wildcard match for all nested subcollections of an application
        match /{subcollection}/{docId} {
          allow get, list: if isOwnerOrAdmin(userId);
          allow create: if isOwnerOrAdmin(userId) && hasValidSubcollectionDataOnCreate(applicationId);
          allow update: if isExistingOwnerOrAdmin(userId) && hasValidSubcollectionDataOnUpdate();
          allow delete: if isExistingOwnerOrAdmin(userId);
        }
      }
    }

    // Rules for listing the admin roles collection
    match /roles_admin {
      allow list: if isSuperAdmin();
    }
    
    // Rules for individual admin role documents
    match /roles_admin/{userId} {
      allow get: if isSignedIn();
      allow write, delete: if isSuperAdmin();
    }
    
    // Rules for listing the super admin roles collection
    match /roles_super_admin {
        allow list: if isSuperAdmin();
    }
    
    // Rules for individual super admin role documents
    match /roles_super_admin/{userId} {
      allow get: if isSignedIn();
      allow write, delete: if isSuperAdmin();
    }
  }
}
