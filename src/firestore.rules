
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy:
     * This ruleset enforces a strict user-ownership model. All user-generated data,
     * such as applications and their related documents, is stored in a hierarchical
     * structure under the user's unique ID (`/users/{userId}`). This ensures that
     * by default, users can only access their own data. An administrative role
     * (`/roles_admin`) is defined to grant privileged read/write access across all
     * user data for administrative purposes.
     *
     * Data Structure:
     * The data is organized hierarchically starting from `/users/{userId}`. Each user
     * document contains a subcollection for their `applications`. All other data
     * points, like contacts, locations, and form statuses, are nested as subcollections
     * under the specific application they relate to. This structure simplifies
     * ownership-based security rules.
     *
     * Key Security Decisions:
     * - Default Deny: All paths are closed by default. Access is granted explicitly.
     * - User Data Isolation: All access controls for the `/users/{userId}` data tree
     *   are based on the `userId` from the path, ensuring a user can only interact
     *   with their own data branch.
     * - No User Enumeration: Listing documents in the top-level `/users` collection is
     *   explicitly forbidden to prevent enumeration of all users or admins, except by admins.
     * - Admin Privileges: Users whose UID exists in the `/roles_admin` collection are
     *   granted full read/write access to all user data for moderation and support.
     * - Admin Role Management: The `/roles_admin` and `/roles_super_admin` collections
     *   are read-only for most users. Roles must be managed by a Super Admin or via the
     *   Firebase Console for maximum security.
     *
     * Denormalization for Authorization:
     * To ensure fast and secure authorization, documents contain fields that simplify
     * rule logic. For example, an `Application` document contains a `userId` field,
     * which is validated against the path on creation to ensure relational integrity.
     * This avoids costly and slow `get()` calls in security rules. The admin role is
     * managed through the existence of a document in `/roles_admin`, which is a
     * simple and performant lookup.
     *
     * Structural Segregation:
     * User data and administrative roles are stored in separate top-level collections
     * (`/users`, `/roles_admin`, `/roles_super_admin`). This clear separation ensures that
     * security rules for application data do not get mixed with rules for administrative
     * access control, leading to a more secure and maintainable ruleset.
     */

    // =================================
    //         Helper Functions
    // =================================

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     * @param userId The UID to check against the authenticated user.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }


    /**
     * Checks if the user has an admin role.
     * Admin status is conferred by the existence of a document for the user
     * in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

     /**
     * Checks if the user has a super admin role.
     * Super Admin status is conferred by the existence of a document for the user
     * in the /roles_super_admin collection.
     */
    function isSuperAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_super_admin/$(request.auth.uid));
    }

    /**
     * Grants access if the user is the owner of the resource OR is an admin or super admin.
     * @param userId The UID of the document's owner.
     */
    function isOwnerOrAdmin(userId) {
      return isOwner(userId) || isAdmin() || isSuperAdmin();
    }

    /**
     * Validates required relational fields on Application document creation.
     * Ensures the internal userId reference points to the correct owner.
     * @param userId The user's UID from the path.
     */
    function hasValidApplicationDataOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces immutability of the Application's owner ID on update.
     */
    function hasValidApplicationDataOnUpdate() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * Validates relational fields for any subcollection document under an application.
     * Ensures the internal applicationId reference points to the correct parent application.
     * @param applicationId The parent application's ID from the path.
     */
    function hasValidSubcollectionDataOnCreate(applicationId) {
      return request.resource.data.applicationId == applicationId;
    }

    /**
     * Enforces immutability of a subcollection document's parent application ID on update.
     */
    function hasValidSubcollectionDataOnUpdate() {
      return request.resource.data.applicationId == resource.data.applicationId;
    }

    // =================================
    //         Collection Rules
    // =================================

    // This rule allows collection group queries on 'applications' for admins.
    match /{path=**}/applications/{applicationId} {
      allow read, write: if isAdmin() || isSuperAdmin();
    }

    /**
     * @description Rules for a user's own profile document.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwnerOrAdmin(userId);
      allow create, update: if isOwner(userId) || isSuperAdmin();
      allow list: if isAdmin() || isSuperAdmin();
      allow delete: if isOwnerOrAdmin(userId);

      /**
       * @description Rules for a user's CalAIM applications.
       * @path /users/{userId}/applications/{applicationId}
       */
      match /applications/{applicationId} {
        allow get, list: if isOwnerOrAdmin(userId);
        allow create: if isOwnerOrAdmin(userId) && hasValidApplicationDataOnCreate(userId);
        allow update: if isOwnerOrAdmin(userId) && hasValidApplicationDataOnUpdate();
        allow delete: if isOwnerOrAdmin(userId);

        /**
         * @description Rules for the internal staff progress tracker.
         * @path /users/{userId}/applications/{applicationId}/staffTrackers/{trackerId}
         */
        match /staffTrackers/{trackerId} {
          allow read, write: if isAdmin() || isSuperAdmin();
        }

        /**
         * @description Generic rules for all subcollections of an application.
         * @path /users/{userId}/applications/{applicationId}/{subcollection}/{docId}
         */
        match /{subcollection}/{docId} {
          allow get, list: if isOwnerOrAdmin(userId);
          allow create: if isOwnerOrAdmin(userId) && hasValidSubcollectionDataOnCreate(applicationId);
          allow update: if isOwnerOrAdmin(userId) && hasValidSubcollectionDataOnUpdate();
          allow delete: if isOwnerOrAdmin(userId);
        }
      }
    }

    /**
     * @description Defines admin roles. The existence of a document grants admin privileges.
     * @path /roles_admin/{userId}
     * @allow (get) Any signed-in user can check if THEY are an admin.
     * @deny (list, write, delete) All other operations are denied for security unless super admin.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn();
      allow list: if isAdmin() || isSuperAdmin();
      allow write, delete: if isSuperAdmin();
    }

    /**
     * @description Defines super admin roles.
     * @path /roles_super_admin/{userId}
     * @allow (get) Any signed-in user can check if THEY are a super admin.
     * @deny (list, write, delete) All other operations are denied unless super admin.
     */
    match /roles_super_admin/{userId} {
      allow get: if isSignedIn();
      allow list: if isSuperAdmin();
      allow write, delete: if isSuperAdmin();
    }

    /**
     * @description Global system settings.
     * @path /system_settings/{settingId}
     * @allow (read) Authenticated users can read settings.
     * @allow (write) Only super admins can write settings.
     */
    match /system_settings/{settingId} {
      allow read: if isSignedIn();
      allow write: if isSuperAdmin();
    }
  }
}
