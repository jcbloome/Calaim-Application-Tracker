/**
 * @file firestore.rules
 * @description Firestore Security Rules for the Git State Restorer application.
 *
 * @section Core Philosophy
 * This ruleset enforces a strict, project-based collaborative security model. All data, including commits and file states,
 * is nested under a parent project. Access is granted based on a user's role within that project, which is defined
 * in a `members` map on the project document itself. This ensures that users can only access data from projects they
 * are explicitly invited to, preventing any cross-project data access.
 *
 * @section Data Structure
 * The data is organized hierarchically to mirror the logical relationship between entities:
 * - /projects/{projectId}: The root document for a project, containing metadata and the authoritative members list.
 * - /projects/{projectId}/commits/{commitId}: A subcollection for all commits belonging to the project.
 * - /projects/{projectId}/commits/{commitId}/fileStates/{fileStateId}: A subcollection for all file states within a specific commit.
 *
 * @section Key Security Decisions
 * - Project Membership is Authoritative: Access to a project and all its sub-collections is determined by a `members`
 *   map on the `/projects/{projectId}` document (e.g., `{ members: { 'user-abc': 'owner', 'user-xyz': 'editor' } }`).
 *   This design decision requires that the `Project` entity contains this map for these rules to function correctly.
 * - Granular Roles: The `members` map supports roles (e.g., 'owner'), allowing for more granular permissions, such as
 *   restricting project deletion or member management to owners only.
 * - Subcollection Security via `get()`: Rules for subcollections (`commits`, `fileStates`) use `get()` to read the parent
 *   project's `members` map to make authorization decisions. This is efficient and ensures a single source of truth for permissions.
 * - Default Deny: All access is denied by default. Permissions are explicitly granted only to signed-in users who are
 *   members of the relevant project. There is no public or anonymous access.
 *
 * @section Denormalization for Authorization
 * The security model critically relies on denormalizing a `members` map onto each `Project` document. This avoids
 * impossible-to-enforce queries (e.g., "find all projects this user is a member of from a separate `memberships` collection")
 * and makes authorization checks for all nested documents simple and performant.
 *
 * @section Structural Segregation
 * The hierarchical structure naturally segregates data by project, which is the primary security boundary. This is a
 * secure and scalable pattern for multi-tenant or collaborative applications.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * @description Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user is listed in the members map of a given project.
     * @note This function assumes the project document contains a `members` map where keys are user UIDs.
     *       Example: `{ name: 'My Project', members: { 'user-uid-123': 'owner' } }`
     */
    function isProjectMember(projectId) {
      let projectData = get(/databases/$(database)/documents/projects/$(projectId)).data;
      return isSignedIn() && request.auth.uid in projectData.members;
    }

    /**
     * @description Checks if the current user has the 'owner' role in the members map of a given project.
     * @note This provides more granular control for administrative actions like deleting a project.
     */
    function isProjectOwner(projectId) {
      let projectData = get(/databases/$(database)/documents/projects/$(projectId)).data;
      return isSignedIn() && projectData.members[request.auth.uid] == 'owner';
    }

    /**
     * @description On create, validates that the user creating the project sets themselves as the owner.
     */
    function creatorIsOwner() {
      return request.resource.data.members[request.auth.uid] == 'owner';
    }

    /**
     * @description On update, ensures critical relational IDs and ownership fields are not changed.
     */
    function coreIdsAreImmutable() {
      return request.resource.data.id == resource.data.id
          && request.resource.data.commitId == resource.data.commitId
          && request.resource.data.projectId == resource.data.projectId;
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Manages project metadata. Access is restricted to users listed in the project's `members` map.
     * @path /projects/{projectId}
     * @allow (get) A signed-in user who is a member of project 'p123' can read its document.
     * @deny (get) A signed-in user who is not a member of project 'p123' cannot read it.
     * @allow (create) A signed-in user can create a new project document, but only if they set themselves as the owner in the `members` map.
     * @deny (delete) A user who is a member but not an 'owner' of project 'p123' cannot delete it.
     * @principle Enforces collaborative, role-based access control at the root of the data tree.
     */
    match /projects/{projectId} {
      allow get: if isProjectMember(projectId);
      allow list: if false; // Deny listing all projects for security. Client must know the project ID.
      allow create: if isSignedIn() && creatorIsOwner();
      allow update: if isProjectOwner(projectId) && resource != null;
      allow delete: if isProjectOwner(projectId) && resource != null;
    }

    /**
     * @description Stores commit metadata for a project. Access is inherited from the parent project's membership.
     * @path /projects/{projectId}/commits/{commitId}
     * @allow (list) A member of project 'p123' can list all commits within that project.
     * @deny (list) A non-member of project 'p123' cannot list any commits.
     * @allow (create) A member of project 'p123' can create a new commit document inside it.
     * @deny (create) A member of project 'p123' cannot create a commit for project 'p456'.
     * @principle Secures a subcollection by checking permissions on the parent document.
     */
    match /projects/{projectId}/commits/{commitId} {
      allow get, list: if isProjectMember(projectId);
      allow create: if isProjectMember(projectId) && request.resource.data.id == commitId;
      allow update: if isProjectMember(projectId) && resource != null && request.resource.data.id == resource.data.id;
      allow delete: if isProjectMember(projectId) && resource != null;
    }

    /**
     * @description Stores file states for a specific commit. Access is inherited from the parent project's membership.
     * @path /projects/{projectId}/commits/{commitId}/fileStates/{fileStateId}
     * @allow (get) A member of project 'p123' can read a file state from any commit in that project.
     * @deny (get) A non-member of project 'p123' cannot read any file state data.
     * @allow (create) A member can create a fileState, provided its internal IDs (`projectId`, `commitId`) match the document path.
     * @deny (update) A member cannot change the `projectId` or `commitId` of an existing fileState.
     * @principle Validates relational integrity to prevent data from being associated with the wrong parent document.
     */
    match /projects/{projectId}/commits/{commitId}/fileStates/{fileStateId} {
      allow get, list: if isProjectMember(projectId);
      // NOTE: The IR 'reasoning' section implies a denormalized `projectId` field on the FileState entity for authorization,
      // which is validated here for relational integrity upon creation.
      allow create: if isProjectMember(projectId) && request.resource.data.id == fileStateId && request.resource.data.commitId == commitId && request.resource.data.projectId == projectId;
      allow update: if isProjectMember(projectId) && resource != null && coreIdsAreImmutable();
      allow delete: if isProjectMember(projectId) && resource != null;
    }
  }
}